import os
import networkx as nx
import pydot
import spacy

from wasabi import msg
from tqdm import tqdm
from typing import List, Tuple, Dict, Optional, Set


class DenotationGraph(object):
    def __init__(self, graph: Optional[nx.DiGraph] = None, graph_folder_path: Optional[str] = None, limit_height: Optional[int] = None) -> None:
        """Creates a DenotationGraph python object from the files generated by the Java code in https://github.com/aylai/DenotationGraph
        Uses the networkx.DiGraph() to create the Directed Graph which can be accessed via the attribute 'graph'

        Arguments:
            graph (nx.DiGraph): Either a prebuilt nx.DiGraph, Default None
            graph_folder_path (str): path to the 'graph' folder created by the above java code, Default None
            limit_height (int): An optional value to limit the height of the graph, Default None.
                This limits the height the height of the graph from the full_caption_leaf_nodes, the other leaf nodes are ignored

            Supply either of the above

        """
        if graph:
            assert isinstance(graph, nx.DiGraph), "graph must be a networkx.DiGraph but got {}".format(type(graph))
            self.graph = graph
        else:
            if graph_folder_path is not None:
                self.graph = DenotationGraph._create_graph(graph_folder_path)
            else:
                raise ValueError("Either graph of graph_folder_path must be given")

        self._find_leaf_nodes()

        if limit_height is not None:
            msg.info("Limiting the height of the Denotation graph to: {} and retaining only the full_caption_leaf_nodes".format(limit_height))
            self = self.make_limited_height_graph(height=limit_height)

    def _find_leaf_nodes(self):
        self.leaf_nodes = [
            node
            for node in tqdm(self.graph.nodes(), desc="Finding leaf nodes...")
            if self.graph.in_degree(node) != 0 and self.graph.out_degree(node) == 0
        ]

        self.full_caption_leaf_nodes = [
            node for node in tqdm(self.leaf_nodes, desc="Finding full caption leaf nodes...") if self.get_node_info(node)["is_full_caption"] is True
        ]

    def is_leaf_node(self, node_idx: int) -> bool:
        if self.graph.in_degree(node_idx) != 0 and self.graph.out_degree(node_idx) == 0:
            return True
        else:
            return False

    def is_root_node(self, node_idx: int) -> bool:
        # this ignores disconnected root nodes
        if self.graph.in_degree(node_idx) == 0 and self.graph.out_degree(node_idx) != 0:
            return True
        else:
            return False

    def get_in_edges(self, node_idx: int) -> List[Tuple[int, int]]:
        return list(self.graph.in_edges(node_idx))

    def get_out_edges(self, node_idx: int) -> List[Tuple[int, int]]:
        return list(self.graph.out_edges(node_idx))

    def get_children_nodes(self, node_idx: int) -> Set[int]:
        return set(self.graph.successors(node_idx))

    def get_parent_nodes(self, node_idx: int) -> Set[int]:
        return set(self.graph.predecessors(node_idx))

    def get_sibling_nodes(self, node_idx: int) -> Dict[int, List[int]]:
        """Finds the sibling nodes

        This returns a dictionary(parent_node_idx: list(siblings)).
        Where each siblings_list belongs to a parent of the given node.
        Each siblings_list contains the siblings from that specific parent.
        """
        siblings = {
            parent: list(
                filter(lambda x: True if x != node_idx else False, self.get_children_nodes(parent))
            )  # filter out the given node from the list
            for parent in self.get_parent_nodes(node_idx)
        }
        return siblings

    def get_cousin_nodes(self, node_idx: int) -> Dict[int, List[int]]:
        """Finds the cousin nodes

        This returns a dictornary(uncle: list(uncle's children))
        """
        cousins = dict()
        for parent in self.get_parent_nodes(node_idx):
            for grand_parent, uncles in self.get_sibling_nodes(parent).items():
                for uncle in uncles:
                    cousins[uncle] = list(
                        filter(
                            lambda x: True if x != node_idx else False, self.get_children_nodes(uncle)
                        )  # Make sure the current node is not present in the children  node of uncle
                        # not sure if this case will ever happen. But just in case
                    )
        return cousins

    def get_ancestors(self, node_idx: int) -> set:
        return nx.ancestors(self.graph, node_idx)

    def get_descendents(self, node_idx: int) -> set:
        return nx.descendants(self.graph, node_idx)

    def __len__(self):
        return len(self.nodes)

    @property
    def nodes(self) -> Set[int]:
        return set(self.graph.nodes)

    @property
    def edges(self) -> List[Tuple[int, int]]:
        # gets only the out going edges of the graph
        return list(self.graph.edges)

    def get_subgraph_from_edges(self, edges: List[Tuple[int, int]]) -> "DenotationGraph":
        return DenotationGraph(graph=self.graph.edge_subgraph(edges))

    def get_subgraph_from_nodes(self, nodes: List[int]) -> "DenotationGraph":
        return DenotationGraph(graph=self.graph.subgraph(nodes))

    def get_node_info(self, node_idx: int) -> dict:
        return self.graph.nodes[node_idx]

    def get_edge_info(self, edge: Tuple[int, int]) -> dict:
        return self.graph.edges[edge]

    def make_limited_height_graph(self, height: int = 3) -> "DenotationGraph":
        """Limits the height of the graph from full sentence level leaf nodes to the given height
        This method makes the changes in place. This uses  only the full_caption_leaf_nodes
        Thus leaf_nodes and full_caption_leaf_nodes will be equal in the end
        Arguments:
            height --int: max height

        Returns the self with removing all the other nodes resulting in a smaller graph
        """
        output_nodes = set()
        for i in range(height):
            if i == 0:
                current_nodes = self.full_caption_leaf_nodes
                output_nodes.update(current_nodes)
            all_current_parents = set()
            for node in current_nodes:
                parents = self.get_parent_nodes(node)
                all_current_parents.update(parents)
            output_nodes.update(all_current_parents)
            current_nodes = all_current_parents
        self.graph.remove_nodes_from([n for n in self.graph.nodes if n not in output_nodes])
        self._find_leaf_nodes()
        assert len(self.leaf_nodes) == len(self.full_caption_leaf_nodes)
        return self

    @staticmethod
    def _create_graph(graph_folder_path) -> None:
        msg.info("Reading node.idx file")
        with open(os.path.join(graph_folder_path, "node.idx"), "r") as f:
            node_idx = f.read().split("\n")

        msg.info("Reading node-cap.map file")
        with open(os.path.join(graph_folder_path, "node-cap.map"), "r") as f:
            node_captions = f.read().split("\n")

        msg.info("Reading node-img.map file")
        with open(os.path.join(graph_folder_path, "node-img.map"), "r") as f:
            node_images = f.read().split("\n")

        msg.info("Reading token.txt file")
        with open(os.path.join(graph_folder_path, "token.txt"), "r") as f:
            all_captions_tokenized = f.read().split("\n")

        all_captions_text = set()
        for token in all_captions_tokenized:
            if token == "":
                continue
            _, caption_text = token.split("\t")
            all_captions_text.add(caption_text)

        assert len(node_idx) == len(node_captions)
        assert len(node_idx) == len(node_images)

        msg.info("Reading the node-tree.txt file")
        with open(os.path.join(graph_folder_path, "node-tree.txt"), "r") as f:
            node_tree = f.read().split("\n")

        graph = nx.DiGraph()
        for idx, images, captions in tqdm(
            zip(node_idx, node_images, node_captions),
            total=len(node_idx),
            desc="Adding nodes to the graph...",
        ):
            if idx == "":
                continue
            i, text = idx.split("\t")
            images = images.split("\t")
            assert images[0] == i
            images = images[1:]
            # remove the caption information from the images and keep only the images
            images = list(set(map(lambda x: x.split("#")[0], images)))
            captions = captions.split("\t")
            assert captions[0] == i
            captions = captions[1:]

            graph.add_node(
                int(i), text=text, images=sorted(images), captions=sorted(captions), is_full_caption=True if text in all_captions_text else False
            )

        for n in tqdm(node_tree, desc="Adding edges to the graph..."):
            if n == "":
                continue
            child, edge, parent, *rewrite_rules = n.split("\t")
            child = int(child)
            parent = int(parent)
            assert child in graph
            assert parent in graph
            graph.add_edge(parent, child, edge_type=edge, rewrite_rules=rewrite_rules)
        return graph


def visualize_denotation_graph(graph: "DenotationGraph", to_file: str, max_samples: int = 2) -> None:
    """Visualize a denotation Graph and save as a PNG file
    graph (DenoationGraph): The graph to visualize
    to_file (str): path to .png file to save the visualization
    max_samples (int): Max number of corresponding images, captions to show in visualization of each node, Default 2
    """
    vis_graph = pydot.Dot(graph_type="digraph")
    for edge in graph.edges:
        vis_graph.add_edge(
            pydot.Edge(
                _format_node(edge[0], graph, max_samples), _format_node(edge[1], graph, max_samples), label=graph.get_edge_info(edge)["edge_type"]
            )
        )
    vis_graph.write_png(to_file)


def _format_node(node_idx, graph, max_samples=2):
    node_info = graph.get_node_info(node_idx)
    return "node index: {}\ntext: {}\nsample images: {}\nsample captions: {}".format(
        node_idx, node_info["text"], node_info["images"][:max_samples], node_info["captions"][:max_samples]
    )


def find_similar_nodes(
    graph: "DenotationGraph", query: str, threshold: float = 0.7, spacy_model: str = "en_core_web_lg", **pipe_kwargs
) -> List[Tuple[int, str, float]]:
    """Finds nodes that are similar to given query using spacy's similarity function

    Arguments:
        graph (DenotationGraph): The denotation graph
        query (str): The query
        threshold (float): Threshold for matching
        spacy_model (str): The spacy model to use. Default "en_core_web_lg"
        **pipe_kwargs : additional keyword arguments to pass to nlp.pipe: https://spacy.io/api/language#pipe

    Returns:
        The list of matches of form (node idx, node text, similarity score) in decreasing order of score
    """
    msg.info("Loading {} model in spacy".format(spacy_model))
    nlp = spacy.load(spacy_model)
    nlp.select_pipes(enable="tok2vec")
    query = nlp(query)

    texts = []
    for node in tqdm(graph.nodes, desc="Finding all text in denotation graph"):
        texts.append(graph.get_node_info(node)["text"])

    matches = []
    for i, t in tqdm(enumerate(nlp.pipe(texts, **pipe_kwargs)), total=len(texts), desc="Finding similar nodes"):
        s = query.similarity(t)
        if s >= threshold:
            matches.append((i, t.text, s))
    return sorted(matches, key=lambda t: t[2])[::-1]
